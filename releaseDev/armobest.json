{
    "name": "ArmoBest",
    "description": "",
    "attributes": {
        "armoBuiltin": true
    },
    "version": null,
    "controls": [
        {
            "name": "API server insecure port is enabled",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "security",
                    "compliance"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "kubeapi",
                        "categories": [
                            "Initial access"
                        ]
                    }
                ]
            },
            "description": "Kubernetes control plane API is running with non-secure port enabled which allows attackers to gain unprotected access to the cluster.",
            "remediation": "Set the insecure-port flag of the API server to zero.",
            "id": "C-0005",
            "long_description": "The control plane is the core of Kubernetes and gives users the ability to view containers, schedule new Pods, read Secrets, and execute commands in the cluster. Therefore, it should be protected. It is recommended to avoid control plane exposure to the Internet or to an untrusted network. The API server runs on ports 6443 and 8080. We recommend to block them in the firewall. Note also that port 8080, when accessed through the local machine, does not require TLS encryption, and the requests bypass authentication and authorization modules.",
            "test": "Check if the insecure-port flag is set (in case of cloud vendor hosted Kubernetes service this verification will not be effective).",
            "controlID": "C-0005",
            "baseScore": 9.0,
            "rules": []
        },
        {
            "name": "Host PID/IPC privileges",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "security",
                    "compliance"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "container",
                        "categories": [
                            "Privilege escalation"
                        ]
                    }
                ]
            },
            "description": "Containers should be isolated from the host machine as much as possible. The hostPID and hostIPC fields in deployment yaml may allow cross-container influence and may expose the host itself to potentially malicious or destructive actions. This control identifies all PODs using hostPID or hostIPC privileges.",
            "remediation": "Remove hostPID and hostIPC from the yaml file(s) privileges unless they are absolutely necessary.",
            "id": "C-0038",
            "long_description": "Containers should be isolated from the host machine as much as possible. The hostPID and hostIPC fields in deployment yaml may allow cross-container influence and may expose the host itself to potentially malicious or destructive actions. This control identifies all PODs using hostPID or hostIPC privileges.",
            "controlID": "C-0038",
            "baseScore": 7.0,
            "example": "@controls/examples/c038.yaml",
            "rules": []
        },
        {
            "name": "Immutable container filesystem",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "security",
                    "compliance"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "container",
                        "categories": [
                            "Execution",
                            "Persistence"
                        ]
                    }
                ]
            },
            "description": "Mutable container filesystem can be abused to inject malicious code or data into containers. Use immutable (read-only) filesystem to limit potential attacks.",
            "remediation": "Set the filesystem of the container to read-only when possible (POD securityContext, readOnlyRootFilesystem: true). If containers application needs to write into the filesystem, it is recommended to mount secondary filesystems for specific directories where application require write access.",
            "id": "C-0017",
            "long_description": "By default, containers are permitted mostly unrestricted execution within their own context. An attacker who has access to a container, can create files and download scripts as he wishes, and modify the underlying application running on the container. ",
            "test": "Check whether the readOnlyRootFilesystem field in the SecurityContext is set to true. ",
            "controlID": "C-0017",
            "baseScore": 3.0,
            "example": "@controls/examples/c017.yaml",
            "rules": []
        },
        {
            "name": "Non-root containers",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "security",
                    "compliance"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "container",
                        "categories": [
                            "Privilege escalation"
                        ]
                    }
                ]
            },
            "description": "Potential attackers may gain access to a container and leverage its existing privileges to conduct an attack. Therefore, it is not recommended to deploy containers with root privileges unless it is absolutely necessary. This control identifies all the Pods running as root or can escalate to root.",
            "remediation": "If your application does not need root privileges, make sure to define the runAsUser or runAsGroup under the PodSecurityContext and use user ID 1000 or higher. Do not turn on allowPrivlegeEscalation bit and make sure runAsNonRoot is true.",
            "id": "C-0013",
            "long_description": "Container engines allow containers to run applications as a non-root user with non-root group membership. Typically, this non-default setting is configured when the container image is built. . Alternatively, Kubernetes can load containers into a Pod with SecurityContext:runAsUser specifying a non-zero user. While the runAsUser directive effectively forces non-root execution at deployment, NSA and CISA encourage developers to build container applications to execute as a non-root user. Having non-root execution integrated at build time provides better assurance that applications will function correctly without root privileges.",
            "test": "Verify if runAsUser  and runAsGroup are set to a user id greater than 999. Check that the allowPrivilegeEscalation field is set to false. Check all the combinations with PodSecurityContext and SecurityContext (for containers).",
            "controlID": "C-0013",
            "baseScore": 6.0,
            "example": "@controls/examples/c013.yaml",
            "rules": []
        },
        {
            "name": "Privileged container",
            "attributes": {
                "armoBuiltin": true,
                "microsoftMitreColumns": [
                    "Privilege escalation"
                ],
                "controlTypeTags": [
                    "security"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "container",
                        "categories": [
                            "Privilege escalation"
                        ]
                    }
                ]
            },
            "description": "Potential attackers may gain access to privileged containers and inherit access to the host resources. Therefore, it is not recommended to deploy privileged containers unless it is absolutely necessary. This control identifies all the privileged Pods.",
            "example": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: privileged\nspec:\n  containers:\n    - name: pause\n      image: k8s.gcr.io/pause\n      securityContext:\n          privileged: true # This field triggers failure!\n",
            "remediation": "Remove privileged capabilities by setting the securityContext.privileged to false. If you must deploy a Pod as privileged, add other restriction to it, such as network policy, Seccomp etc and still remove all unnecessary capabilities. Use the exception mechanism to remove unnecessary notifications.",
            "id": "C-0057",
            "long_description": "A privileged container is a container that has all the capabilities of the host machine, which lifts all the limitations regular containers have. Practically, this means that privileged containers can do almost every action that can be performed directly on the host. Attackers who gain access to a privileged container or have permissions to create a new privileged container (by using the compromised pod\u2019s service account, for example), can get access to the host\u2019s resources.",
            "test": "Check in POD spec if securityContext.privileged == true, if so raise an alert.",
            "controlID": "C-0057",
            "baseScore": 8.0,
            "rules": []
        },
        {
            "name": "Automatic mapping of service account",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "security",
                    "compliance"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "container",
                        "categories": [
                            "Credential access",
                            "Impact - K8s API access"
                        ]
                    }
                ]
            },
            "description": "Potential attacker may gain access to a POD and steal its service account token. Therefore, it is recommended to disable automatic mapping of the service account tokens in service account configuration and enable it only for PODs that need to use them.",
            "remediation": "Disable automatic mounting of service account tokens to PODs either at the service account level or at the individual POD level, by specifying the automountServiceAccountToken: false. Note that POD level takes precedence.",
            "id": "C-0034",
            "long_description": "We have it in Armo best (Automatic mapping of service account token).",
            "test": "Check all service accounts on which automount is not disabled.  Check all workloads on which they and their service account don't disable automount ",
            "controlID": "C-0034",
            "baseScore": 6.0,
            "example": "@controls/examples/c034.yaml",
            "rules": []
        },
        {
            "name": "HostNetwork access",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "security",
                    "compliance"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "container",
                        "categories": [
                            "Discovery",
                            "Lateral movement",
                            "Impact - service access"
                        ]
                    }
                ]
            },
            "description": "Potential attackers may gain access to a POD and inherit access to the entire host network. For example, in AWS case, they will have access to the entire VPC. This control identifies all the PODs with host network access enabled.",
            "remediation": "Only connect PODs to host network when it is necessary. If not, set the hostNetwork field of the pod spec to false, or completely remove it (false is the default). Whitelist only those PODs that must have access to host network by design.",
            "id": "C-0041",
            "long_description": "We have it in ArmoBest",
            "test": "",
            "controlID": "C-0041",
            "baseScore": 7.0,
            "example": "@controls/examples/c041.yaml",
            "rules": []
        },
        {
            "name": "Resource limits",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "security"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "container",
                        "categories": [
                            "Impact - service destruction"
                        ]
                    }
                ]
            },
            "description": "CPU and memory resources should have a limit set for every container or a namespace to prevent resource exhaustion. This control identifies all the Pods without resource limit definitions by checking their yaml definition file as well as their namespace LimitRange objects. It is also recommended to use ResourceQuota object to restrict overall namespace resources, but this is not verified by this control.",
            "remediation": "Define LimitRange and Resource Limits in the namespace or in the deployment/POD yamls.",
            "id": "C-0009",
            "long_description": "CPU and memory resources should have a limit set for every container or a namespace to prevent resource exhaustion. This control identifies all the Pods without resource limit definitions by checking their yaml definition file as well as their namespace LimitRange objects. It is also recommended to use ResourceQuota object to restrict overall namespace resources, but this is not verified by this control.",
            "test": " Check for each container if there is a \u2018limits\u2019 field defined for both cpu and memory",
            "controlID": "C-0009",
            "baseScore": 7.0,
            "example": "@controls/examples/c009.yaml",
            "rules": []
        },
        {
            "name": "Allow privilege escalation",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "security",
                    "compliance"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "container",
                        "categories": [
                            "Privilege escalation"
                        ]
                    }
                ]
            },
            "description": "Attackers may gain access to a container and uplift its privilege to enable excessive capabilities.",
            "remediation": "If your application does not need it, make sure the allowPrivilegeEscalation field of the securityContext is set to false.",
            "id": "C-0016",
            "test": " Check that the allowPrivilegeEscalation field in securityContext of container is set to false.   ",
            "controlID": "C-0016",
            "baseScore": 6.0,
            "example": "@controls/examples/allowprivilegeescalation.yaml",
            "rules": []
        },
        {
            "name": "Applications credentials in configuration files",
            "attributes": {
                "armoBuiltin": true,
                "microsoftMitreColumns": [
                    "Credential access",
                    "Lateral Movement"
                ],
                "controlTypeTags": [
                    "security",
                    "compliance",
                    "security-impact"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "kubeapi",
                        "categories": [
                            "Credential access"
                        ]
                    },
                    {
                        "attackTrack": "container",
                        "categories": [
                            "Credential access"
                        ]
                    }
                ]
            },
            "description": "Attackers who have access to configuration files can steal the stored secrets and use them. This control checks if ConfigMaps or pod specifications have sensitive information in their configuration.",
            "remediation": "Use Kubernetes secrets or Key Management Systems to store credentials.",
            "id": "C-0012",
            "long_description": "Developers store secrets in the Kubernetes configuration files, such as environment variables in the pod configuration. Such behavior is commonly seen in clusters that are monitored by Azure Security Center. Attackers who have access to those configurations, by querying the API server or by accessing those files on the developer\u2019s endpoint, can steal the stored secrets and use them.",
            "test": "Check if the pod has sensitive information in environment variables, by using list of known sensitive key names. Check if there are configmaps with sensitive information.",
            "controlID": "C-0012",
            "baseScore": 8.0,
            "rules": []
        },
        {
            "name": "Cluster-admin binding",
            "attributes": {
                "armoBuiltin": true,
                "microsoftMitreColumns": [
                    "Privilege escalation"
                ],
                "rbacQuery": "Show cluster_admin",
                "controlTypeTags": [
                    "security",
                    "compliance"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "kubeapi",
                        "categories": [
                            "Impact - data destruction",
                            "Impact - service injection"
                        ]
                    }
                ]
            },
            "description": "Attackers who have cluster admin permissions (can perform any action on any resource), can take advantage of their privileges for malicious activities. This control determines which subjects have cluster admin permissions.",
            "remediation": "You should apply least privilege principle. Make sure cluster admin permissions are granted only when it is absolutely necessary. Don't use subjects with such high permissions for daily operations.",
            "id": "C-0035",
            "long_description": "Role-based access control (RBAC) is a key security feature in Kubernetes. RBAC can restrict the allowed actions of the various identities in the cluster. Cluster-admin is a built-in high privileged role in Kubernetes. Attackers who have permissions to create bindings and cluster-bindings in the cluster can create a binding to the cluster-admin ClusterRole or to other high privileges roles.",
            "test": "Check which subjects have cluster-admin RBAC permissions \u2013 either by being bound to the cluster-admin clusterrole, or by having equivalent high privileges.  ",
            "controlID": "C-0035",
            "baseScore": 6.0,
            "rules": []
        },
        {
            "name": "Exec into container",
            "attributes": {
                "armoBuiltin": true,
                "microsoftMitreColumns": [
                    "Execution"
                ],
                "rbacQuery": "Show who can access into pods",
                "controlTypeTags": [
                    "compliance",
                    "security-impact"
                ]
            },
            "description": "Attackers with relevant permissions can run malicious commands in the context of legitimate containers in the cluster using \u201ckubectl exec\u201d command. This control determines which subjects have permissions to use this command.",
            "remediation": "It is recommended to prohibit \u201ckubectl exec\u201d command in production environments. It is also recommended not to use subjects with this permission for daily cluster operations.",
            "id": "C-0002",
            "long_description": "Attackers who have permissions, can run malicious commands in containers in the cluster using exec command (\u201ckubectl exec\u201d). In this method, attackers can use legitimate images, such as an OS image (e.g., Ubuntu) as a backdoor container, and run their malicious code remotely by using \u201ckubectl exec\u201d.",
            "test": "Check which subjects have RBAC permissions to exec into pods\u2013 if they have the \u201cpods/exec\u201d verb.",
            "controlID": "C-0002",
            "baseScore": 5.0,
            "example": "@controls/examples/c002.yaml",
            "rules": []
        },
        {
            "name": "Insecure capabilities",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "security",
                    "compliance"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "container",
                        "categories": [
                            "Privilege escalation"
                        ]
                    }
                ]
            },
            "description": "Giving insecure or excessive capabilities to a container can increase the impact of the container compromise. This control identifies all the PODs with dangerous capabilities (see documentation pages for details).",
            "remediation": "Remove all insecure capabilities which are not necessary for the container.",
            "id": "C-0046",
            "long_description": "Giving  insecure and unnecessary capabilities for a container can increase the impact of a container compromise.",
            "test": "Check capabilities given against a configurable blacklist of insecure capabilities (https://man7.org/linux/man-pages/man7/capabilities.7.html). ",
            "controlID": "C-0046",
            "baseScore": 7.0,
            "example": "@controls/examples/c046.yaml",
            "rules": []
        },
        {
            "name": "Linux hardening",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "security",
                    "compliance"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "container",
                        "categories": [
                            "Privilege escalation"
                        ]
                    }
                ]
            },
            "description": "Containers may be given more privileges than they actually need. This can increase the potential impact of a container compromise.",
            "remediation": "You can use AppArmor, Seccomp, SELinux and Linux Capabilities mechanisms to restrict containers abilities to utilize unwanted privileges.",
            "id": "C-0055",
            "long_description": "In order to reduce the attack surface, it is recommend, when it is possible, to harden your application using security services such as SELinux\u00ae, AppArmor\u00ae, and seccomp. Starting from Kubernetes version 22, SELinux is enabled by default. ",
            "test": "Check if there is AppArmor or Seccomp or SELinux or Capabilities are defined in the securityContext of container and pod. If none of these fields are defined for both the container and pod, alert.",
            "controlID": "C-0055",
            "baseScore": 4.0,
            "rules": []
        },
        {
            "name": "Ingress and Egress blocked",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "compliance"
                ]
            },
            "description": "Disable Ingress and Egress traffic on all pods wherever possible. It is recommended to define restrictive network policy on all new PODs, and then enable sources/destinations that this POD must communicate with.",
            "remediation": "Define a network policy that restricts ingress and egress connections.",
            "id": "C-0030",
            "long_description": "Network policies control traffic flow between Pods, namespaces, and external IP addresses. By default, no network policies are applied to Pods or namespaces, resulting in unrestricted ingress and egress traffic within the Pod network. Pods become isolated through a network policy that applies to the Pod or the Pod\u2019s namespace. Once a Pod is selected in a network policy, it rejects any connections that are not specifically allowed by any applicable policy object.Administrators should use a default policy selecting all Pods to deny all ingress and egress traffic and ensure any unselected Pods are isolated. Additional policies could then relax these restrictions for permissible connections.",
            "test": "Check for each Pod whether there is an ingress and egress policy defined (whether using Pod or Namespace). ",
            "controlID": "C-0030",
            "baseScore": 6.0,
            "example": "@controls/examples/c030.yaml",
            "rules": []
        },
        {
            "name": "Container hostPort",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "security",
                    "compliance",
                    "devops"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "container",
                        "categories": [
                            "Initial access"
                        ]
                    }
                ]
            },
            "description": "Configuring hostPort requires a particular port number. If two objects specify the same HostPort, they could not be deployed to the same node. It may prevent the second object from starting, even if Kubernetes will try reschedule it on another node, provided there are available nodes with sufficient amount of resources. Also, if the number of replicas of such workload is higher than the number of nodes, the deployment will consistently fail.",
            "remediation": "Avoid usage of hostPort unless it is absolutely necessary, in which case define appropriate exception. Use NodePort / ClusterIP instead.",
            "id": "C-0044",
            "long_description": "Workloads (like pod, deployment, etc) that contain a container with hostport. The problem that arises is that if the scale of your workload is larger than the number of nodes in your Kubernetes cluster, the deployment fails. And any two workloads that specify the same HostPort cannot be deployed to the same node. In addition, if the host where your pods are running becomes unavailable, Kubernetes reschedules the pods to different nodes. Thus, if the IP address for your workload changes, external clients of your application will lose access to the pod. The same thing happens when you restart your pods \u2014 Kubernetes reschedules them to a different node if available.\u00a0",
            "test": "Check for each workload (with container) if it exists inside the container hostPort.\u00a0\u00a0",
            "controlID": "C-0044",
            "baseScore": 4.0,
            "example": "@controls/examples/c044.yaml",
            "rules": []
        },
        {
            "name": "CVE-2021-25741 - Using symlink for arbitrary host file system access.",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "security",
                    "compliance"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "container",
                        "categories": [
                            "Persistence",
                            "Impact - Data access in container"
                        ]
                    }
                ]
            },
            "description": "A user may be able to create a container with subPath or subPathExpr volume mounts to access files & directories anywhere on the host filesystem. Following Kubernetes versions are affected: v1.22.0 - v1.22.1, v1.21.0 - v1.21.4, v1.20.0 - v1.20.10, version v1.19.14 and lower. This control checks the vulnerable versions and the actual usage of the subPath feature in all Pods in the cluster. If you want to learn more about the CVE, please refer to the CVE link: https://nvd.nist.gov/vuln/detail/CVE-2021-25741",
            "remediation": "To mitigate this vulnerability without upgrading kubelet, you can disable the VolumeSubpath feature gate on kubelet and kube-apiserver, or remove any existing Pods using subPath or subPathExpr feature.",
            "id": "C-0058",
            "controlID": "C-0058",
            "baseScore": 6.0,
            "rules": []
        },
        {
            "name": "CVE-2021-25742-nginx-ingress-snippet-annotation-vulnerability",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "security",
                    "compliance"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "container",
                        "categories": [
                            "Initial access",
                            "Execution"
                        ]
                    }
                ]
            },
            "description": "Security issue in ingress-nginx where a user that can create or update ingress objects can use the custom snippets feature to obtain all secrets in the cluster (see more at https://github.com/kubernetes/ingress-nginx/issues/7837)",
            "remediation": "To mitigate this vulnerability: 1. Upgrade to a version that allows mitigation (>= v0.49.1 or >= v1.0.1), 2. Set allow-snippet-annotations to false in your ingress-nginx ConfigMap based on how you deploy ingress-nginx",
            "test": "The control checks if the nginx-ingress-controller contains the ability to disable allowSnippetAnnotations and that indeed this feature is turned off",
            "id": "C-0059",
            "controlID": "C-0059",
            "baseScore": 8.0,
            "rules": []
        },
        {
            "name": "No impersonation",
            "attributes": {
                "armoBuiltin": true,
                "rbacQuery": "Impersonation",
                "controlTypeTags": [
                    "security",
                    "compliance"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "kubeapi",
                        "categories": [
                            "Privilege escalation"
                        ]
                    }
                ]
            },
            "description": "Impersonation is an explicit RBAC permission to use other roles rather than the one assigned to a user, group or service account. This is sometimes needed for testing purposes. However, it is highly recommended not to use this capability in the production environments for daily operations. This control identifies all subjects whose roles include impersonate verb.",
            "remediation": "Either remove the impersonate verb from the role where it was found or make sure that this role is not bound to users, groups or service accounts used for ongoing cluster operations. If necessary, bind this role to a subject only for specific needs for limited time period.",
            "long_description": "Impersonation is an explicit RBAC permission to use other roles rather than the one assigned to a user, group or service account. This is sometimes needed for testing purposes. However, it is highly recommended not to use this capability in the production environments for daily operations. This control identifies all subjects whose roles include impersonate verb.",
            "test": "Check for RBACs giving 'impersonate' verb to users/groups/uids/serviceaccounts",
            "id": "C-0065",
            "controlID": "C-0065",
            "baseScore": 6.0,
            "example": "@controls/examples/c065.yaml",
            "rules": []
        },
        {
            "name": "Pods in default namespace",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "compliance",
                    "devops"
                ]
            },
            "description": "It is recommended to avoid running PODs in cluster without explicit namespace assignment. This control identifies all the PODs running in the default namespace.",
            "remediation": "Create necessary namespaces and move all the PODs from default namespace there.",
            "id": "C-0061",
            "long_description": "It is recommended to avoid running PODs in cluster without explicit namespace assignment. This may lead to wrong capabilities and permissions assignment and potential compromises. This control identifies all the PODs running in the default namespace.",
            "test": "Check that there are no pods in the 'default' namespace",
            "controlID": "C-0061",
            "baseScore": 3,
            "rules": []
        },
        {
            "name": "Sudo in container entrypoint",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "security"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "container",
                        "categories": [
                            "Privilege escalation"
                        ]
                    }
                ]
            },
            "description": "Adding sudo to a container entry point command may escalate process privileges and allow access to forbidden resources. This control checks all the entry point commands in all containers in the POD to find those that have sudo command.",
            "remediation": "Remove sudo from the command line and use Kubernetes native root and capabilities controls to provide necessary privileges where they are required.",
            "id": "C-0062",
            "long_description": "Adding sudo to a container entry point command may escalate process privileges and allow access to forbidden resources. This control checks all the entry point commands in all containers in the POD to find those that have sudo command.",
            "test": "Check that there is no 'sudo' in the container entrypoint",
            "controlID": "C-0062",
            "baseScore": 5.0,
            "example": "@controls/examples/c062.yaml",
            "rules": []
        },
        {
            "name": "Portforwarding privileges",
            "attributes": {
                "armoBuiltin": true,
                "rbacQuery": "Port Forwarding",
                "controlTypeTags": [
                    "security-impact",
                    "compliance"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "kubeapi",
                        "categories": [
                            "Impact - data destruction",
                            "Discovery",
                            "Lateral movement"
                        ]
                    }
                ]
            },
            "description": "Attackers with relevant RBAC permission can use \u201ckubectl portforward\u201d command to establish direct communication with PODs from within the cluster or even remotely. Such communication will most likely bypass existing security measures in the cluster. This control determines which subjects have permissions to use this command.",
            "remediation": "It is recommended to prohibit \u201ckubectl portforward\u201d command in production environments. It is also recommended not to use subjects with this permission for daily cluster operations.",
            "id": "C-0063",
            "long_description": "Attackers who have relevant RBAC permissions, can run open a backdoor communication channel directly to the sockets inside target container using exec command \u201ckubectl portforward\u201d command. Using this method, attackers can bypass network security restrictions and communicate directly with software in the containers.",
            "test": "Check which subjects have RBAC permissions to portforward into pods\u2013 if they have the \u201cpods/portforward\u201d resource.",
            "controlID": "C-0063",
            "baseScore": 5.0,
            "example": "@controls/examples/c063.yaml",
            "rules": []
        },
        {
            "name": "Cluster internal networking",
            "attributes": {
                "armoBuiltin": true,
                "microsoftMitreColumns": [
                    "Lateral movement"
                ],
                "controlTypeTags": [
                    "security",
                    "compliance"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "container",
                        "categories": [
                            "Discovery",
                            "Lateral movement"
                        ]
                    }
                ]
            },
            "description": "If no network policy is defined, attackers who gain access to a container may use it to move laterally in the cluster. This control lists namespaces in which no network policy is defined.",
            "remediation": "Define Kubernetes network policies or use alternative products to protect cluster network.",
            "id": "C-0054",
            "long_description": "Kubernetes networking behavior allows traffic between pods in the cluster as a default behavior. Attackers who gain access to a single container may use it for network reachability to another container in the cluster.",
            "test": "Check for each namespace if there is a network policy defined.",
            "controlID": "C-0054",
            "baseScore": 4.0,
            "rules": []
        },
        {
            "name": "Audit logs enabled",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "security",
                    "compliance"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "container",
                        "categories": [
                            "Defense evasion - KubeAPI"
                        ]
                    }
                ]
            },
            "description": "Audit logging is an important security feature in Kubernetes, it enables the operator to track requests to the cluster. It is important to use it so the operator has a record of events happened in Kubernetes",
            "remediation": "Turn on audit logging for your cluster. Look at the vendor guidelines for more details",
            "id": "C-0067",
            "long_description": "Audit logging is an important security feature in Kubernetes, it enables the operator to track requests to the cluster. It is important to use it so the operator has a record of events happened in Kubernetes",
            "test": "Reading the cluster description from the managed cloud API (EKS, GKE), or the API server pod configuration for native K8s and checking if audit logging is enabled",
            "controlID": "C-0067",
            "baseScore": 5.0,
            "rules": []
        },
        {
            "name": "Secret/ETCD encryption enabled",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "security",
                    "compliance"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "node",
                        "categories": [
                            "Impact"
                        ]
                    }
                ]
            },
            "description": "All Kubernetes Secrets are stored primarily in etcd therefore it is important to encrypt it.",
            "remediation": "Turn on the etcd encryption in your cluster, for more see the vendor documentation.",
            "id": "C-0066",
            "long_description": "etcd is a consistent and highly-available key value store used as Kubernetes' backing store for all cluster data. All object data in Kubernetes, like secrets, are stored there. This is the reason why it is important to protect the contents of etcd and use its data encryption feature.",
            "test": "Reading the cluster description from the managed cloud API (EKS, GKE), or the API server pod configuration for native K8s and checking if etcd encryption is enabled",
            "controlID": "C-0066",
            "baseScore": 6.0,
            "rules": []
        },
        {
            "name": "PSP enabled",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "security",
                    "compliance"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "kubeapi",
                        "categories": [
                            "Impact - service injection"
                        ]
                    }
                ]
            },
            "description": "PSP enable fine-grained authorization of pod creation and it is important to enable it",
            "remediation": "Turn Pod Security Policies on in your cluster, if you use other admission controllers to control the behavior that PSP controls, exclude this control from your scans",
            "id": "C-0068",
            "long_description": "Pod Security Policies enable fine-grained authorization of pod creation and updates and it extends authorization  beyond RBAC. It is an important to use PSP to control the creation of sensitive PODs in your cluster.",
            "test": "Reading the cluster description from the managed cloud API (EKS, GKE), or the API server pod configuration for native K8s and checking if PSP is enabled",
            "controlID": "C-0068",
            "baseScore": 1.0,
            "rules": []
        },
        {
            "name": "Disable anonymous access to Kubelet service",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "security",
                    "compliance"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "kubeapi",
                        "categories": [
                            "Initial access"
                        ]
                    }
                ]
            },
            "description": "By default, requests to the kubelet's HTTPS endpoint that are not rejected by other configured authentication methods are treated as anonymous requests, and given a username of system:anonymous and a group of system:unauthenticated.",
            "remediation": "Start the kubelet with the --anonymous-auth=false flag.",
            "id": "C-0069",
            "long_description": "By default, requests to the kubelet's HTTPS endpoint that are not rejected by other configured authentication methods are treated as anonymous requests, and given a username of system:anonymous and a group of system:unauthenticated.",
            "test": "Reading the kubelet command lines and configuration file looking for anonymous-auth configuration. If this configuration is set on both, the command line values take precedence over it.",
            "controlID": "C-0069",
            "baseScore": 10,
            "rules": []
        },
        {
            "name": "Enforce Kubelet client TLS authentication",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "security",
                    "compliance"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "node",
                        "categories": [
                            "Initial access"
                        ]
                    }
                ]
            },
            "description": "Kubelets are the node level orchestrator in Kubernetes control plane. They are publishing service port 10250 where they accept commands from API server. Operator must make sure that only API server is allowed to submit commands to Kubelet. This is done through client certificate verification, must configure Kubelet with client CA file to use for this purpose.",
            "remediation": "Start the kubelet with the --client-ca-file flag, providing a CA bundle to verify client certificates with.",
            "id": "C-0070",
            "long_description": "Kubelets are the node level orchestrator in Kubernetes control plane. They are publishing service port 10250 where they accept commands from API server. Operator must make sure that only API server is allowed to submit commands to Kubelet. This is done through client certificate verification, must configure Kubelet with client CA file to use for this purpose.",
            "test": "Reading the kubelet command lines and configuration file looking for client TLS configuration.",
            "controlID": "C-0070",
            "baseScore": 9.0,
            "rules": []
        },
        {
            "name": "Forbidden Container Registries",
            "attributes": {
                "armoBuiltin": true,
                "microsoftMitreColumns": [
                    "Initial Access"
                ],
                "controlTypeTags": [
                    "security",
                    "compliance"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "container",
                        "categories": [
                            "Initial access"
                        ]
                    }
                ]
            },
            "description": "In cases where the Kubernetes cluster is provided by a CSP (e.g., AKS in Azure, GKE in GCP, or EKS in AWS), compromised cloud credential can lead to the cluster takeover. Attackers may abuse cloud account credentials or IAM mechanism to the cluster\u2019s management layer.",
            "remediation": "Limit the registries from which you pull container images from",
            "id": "C-0001",
            "long_description": "Running a compromised image in a cluster can compromise the cluster. Attackers who get access to a private registry can plant their own compromised images in the registry. The latter can then be pulled by a user. In addition, users often use untrusted images from public registries (such as Docker Hub) that may be malicious. Building images based on untrusted base images can also lead to similar results.",
            "test": "Checking image from pod spec, if the registry of the image is from the list of blocked registries we raise an alert.",
            "controlID": "C-0001",
            "baseScore": 7.0,
            "example": "@controls/examples/c001.yaml",
            "rules": []
        },
        {
            "name": "CVE-2022-0185-linux-kernel-container-escape",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "security",
                    "compliance"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "container",
                        "categories": [
                            "Privilege escalation"
                        ]
                    }
                ]
            },
            "description": "CVE-2022-0185 is a kernel vulnerability enabling privilege escalation and it can lead attackers to escape containers and take control over nodes. This control alerts on vulnerable kernel versions of Kubernetes nodes",
            "remediation": "Patch Linux kernel version to 5.16.2 or above",
            "id": "C-0079",
            "long_description": "Linux maintainers disclosed a broadly available Linux kernel vulnerability (CVE-2022-0185) which enables attackers to escape containers and get full control over the node. In order to be able to exploit this vulnerability, the attacker needs to be able to run code on in the container and the container must have CAP_SYS_ADMIN privileges. Linux kernel and all major distro maintainers have released patches. This control alerts on vulnerable kernel versions of Kubernetes nodes.",
            "test": "Checking Linux kernel version of the Node objects, if it is above 5.1 or below 5.16.2 it fires an alert",
            "controlID": "C-0079",
            "baseScore": 4.0,
            "example": "",
            "rules": []
        },
        {
            "name": "Network mapping",
            "attributes": {
                "armoBuiltin": true,
                "microsoftMitreColumns": [
                    "Discovery"
                ],
                "controlTypeTags": [
                    "security",
                    "compliance"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "container",
                        "categories": [
                            "Discovery"
                        ]
                    }
                ]
            },
            "description": "If no network policy is defined, attackers who gain access to a single container may use it to probe the network. This control lists all namespaces in which no network policies are defined.",
            "remediation": "Define network policies or use similar network protection mechanisms.",
            "id": "C-0049",
            "long_description": "Attackers may try to map the cluster network to get information on the running applications, including scanning for known vulnerabilities. By default, there is no restriction on pods communication in Kubernetes. Therefore, attackers who gain access to a single container, may use it to probe the network.",
            "test": "Check for each namespace if there is a network policy defined.",
            "controlID": "C-0049",
            "baseScore": 3.0,
            "example": "@controls/examples/c049.yaml",
            "rules": []
        },
        {
            "name": "Images from allowed registry",
            "attributes": {
                "armoBuiltin": true,
                "microsoftMitreColumns": [
                    "Collection"
                ],
                "controlTypeTags": [
                    "security",
                    "compliance"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "container",
                        "categories": [
                            "Initial access",
                            "Execution"
                        ]
                    }
                ]
            },
            "description": "This control is intended to ensure that all the used container images are taken from the authorized repositories. It allows user to list all the approved repositories and will fail all the images taken from any repository outside of this list.",
            "remediation": "You should enable all trusted repositories in the parameters of this control.",
            "id": "C-0078",
            "long_description": "If attackers get access to the cluster, they can re-point kubernetes to a compromized container repository. This control is intended to ensure that all the container images are taken from the authorized repositories only. User should list all the approved repositories in the parameters of this control so that any potential dangerous image can be identified.",
            "test": "Checks if image is from allowed listed registry.",
            "controlID": "C-0078",
            "baseScore": 5.0,
            "rules": []
        },
        {
            "name": "CVE-2022-0492-cgroups-container-escape",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "security",
                    "compliance"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "container",
                        "categories": [
                            "Privilege escalation"
                        ]
                    }
                ]
            },
            "description": "Linux Kernel vulnerability CVE-2022-0492 may allow malicious code running inside container to escape container isolation and gain root privileges on the entire node. When fixed Kernel version numbers will become available, this control will be modified to verify them and avoid false positive detections. This control identifies all the resources that don't deploy neither AppArmor nor SELinux, run as root or allow privileged escalation or have corresponding dangerous capabilities.",
            "remediation": "Activate AppArmor or SELinux. Follow the least privilege principle and remove root privileges or privilege escalation option and CAP_DAC_OVERRIDE capability. Make sure you don't allow container images from potentially dangerous sources and that containers that must have high privileges are taken from protected repositories.",
            "id": "C-0086",
            "long_description": "Linux Kernel vulnerability CVE-2022-0492 may allow malicious code running inside container to escape container isolation and gain root privileges on the entire node. In order to exploit this vulnerability, malicious code should run as root in the container or have CAP_DAC_OVERRIDE capability. If SELinux or AppArmor is deployed, this CVE becomes not exploitable. Also, the exploit is possible when container runtime uses cgroup version 1 implementation (which we assume is on by default, since it is not visible from the Kubernetes level). When fixed Kernel version numbers will become available, this control will be modified to verify them and avoid false positive detections. Note, it is enough to have a single node in the cluster with vulnerable Kernel in order to damage the system. This control identifies all the resources that don't deploy niether AppArmor nor SELinux, run as root or allow privileged escalation or have corresponding dangerous capabilities.",
            "test": "This control checks whether the container is running with high privileges (root or CAP_DAC_OVERRIDE capability) and doesn't have SELinux or AppArmor enabled. In case where the container is running with CAP_DAC_OVERRIDE capability, we also check for Seccomp, as it's enough to prevent the exploitation in this case.",
            "controlID": "C-0086",
            "baseScore": 4.0,
            "example": "",
            "rules": []
        },
        {
            "name": "CVE-2022-24348-argocddirtraversal",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "security"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "container",
                        "categories": [
                            "Privilege escalation"
                        ]
                    }
                ]
            },
            "description": "CVE-2022-24348 is a major software supply chain 0-day vulnerability in the popular open source CD platform Argo CD which can lead to privilege escalation and information disclosure.",
            "remediation": "Update your ArgoCD deployment to fixed versions (v2.1.9,v2.2.4 or v2.3.0)",
            "id": "C-0081",
            "long_description": "CVE-2022-24348 is a major software supply chain 0-day vulnerability in the popular open source CD platform Argo CD. Exploiting it enables attackers to obtain sensitive information like credentials, secrets, API keys from other applications on the platform. This in turn can lead to privilege escalation, lateral movements and information disclosure.",
            "test": "Checking Linux kernel version of the Node objects, if it is above 5.1 or below 5.16.2 it fires an alert",
            "controlID": "C-0081",
            "baseScore": 4.0,
            "example": "",
            "rules": []
        },
        {
            "name": "CVE-2022-23648-containerd-fs-escape",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "security"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "container",
                        "categories": [
                            "Privilege escalation",
                            "Impact - Data access in container"
                        ]
                    }
                ]
            },
            "description": "CVE-2022-23648 is a vulnerability of containerd enabling attacker to gain access to read-only copies of arbitrary files from the host using aspecially-crafted POD configuration yamls",
            "remediation": "Patch containerd to 1.6.1, 1.5.10, 1.4.12  or above",
            "id": "C-0087",
            "long_description": "Containerd is a container runtime available as a daemon for Linux and Windows. A bug was found in containerd prior to versions 1.6.1, 1.5.10, and 1.4.12 where containers launched through containerd\u2019s CRI implementation on Linux with a specially-crafted image configuration could gain access to read-only copies of arbitrary files and directories on the host. This may bypass any policy-based enforcement on container setup (including a Kubernetes Pod Security Policy) and expose potentially sensitive information. This bug was fixed in containerd versions 1.6.1, 1.5.10, and 1.4.12. Users should update to these versions to resolve the issue.",
            "test": "Checking containerd version to see if it is a vulnerable version (where the container runtime is containerd)",
            "controlID": "C-0087",
            "baseScore": 7.0,
            "example": "",
            "rules": []
        },
        {
            "name": "Workloads with excessive amount of vulnerabilities",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "security",
                    "compliance"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "container",
                        "categories": [
                            "Initial access",
                            "Execution"
                        ]
                    }
                ]
            },
            "description": "Container images with multiple Critical and High sevirity vulnerabilities increase the risk of potential exploit. This control lists all such images according to the threashold provided by the customer.",
            "remediation": "Update your workload images as soon as possible when fixes become available.",
            "id": "C-0085",
            "long_description": "Container images with multiple Critical and High sevirity vulnerabilities increase the risk of potential exploit. This control lists all such images according to the threashold provided by the customer.",
            "test": "This control enumerates workloads and checks if they have excessive amount of vulnerabilities in their container images. The threshold of \u201cexcessive number\u201d is configurable.",
            "controlID": "C-0085",
            "baseScore": 6.0,
            "example": "@controls/examples/c85.yaml",
            "rules": []
        },
        {
            "name": "Workloads with Critical vulnerabilities exposed to external traffic",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "security"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "container",
                        "categories": [
                            "Initial access",
                            "Execution"
                        ]
                    }
                ]
            },
            "description": "Container images with known critical vulnerabilities pose elevated risk if they are exposed to the external traffic. This control lists all images with such vulnerabilities if either LoadBalancer or NodePort service is assigned to them.",
            "remediation": "Either update the container image to fix the vulnerabilities (if such fix is available) or reassess if this workload must be exposed to the outseide traffic. If no fix is available, consider periodic restart of the POD to minimize the risk of persistant intrusion. Use exception mechanism if you don't want to see this report again.",
            "id": "C-0083",
            "long_description": "Container images with known critical vulnerabilities pose elevated risk if they are exposed to the external traffic. This control lists all images with such vulnerabilities if either LoadBalancer or NodePort service assigned to them.",
            "test": "This control enumerates external facing workloads, that have LoadBalancer or NodePort services and checks image vulnerability information to see if the image has critical vulnerabilities.",
            "controlID": "C-0083",
            "baseScore": 8.0,
            "example": "@controls/examples/c83.yaml",
            "rules": []
        },
        {
            "name": "Workloads with RCE vulnerabilities exposed to external traffic",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "security",
                    "compliance"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "container",
                        "categories": [
                            "Initial access",
                            "Execution"
                        ]
                    }
                ]
            },
            "description": "Container images with known Remote Code Execution (RCE) vulnerabilities pose significantly higher risk if they are exposed to the external traffic. This control lists all images with such vulnerabilities if their POD has either LoadBalancer or NodePort service.",
            "remediation": "Either update the container image to fix the vulnerabilities (if such fix is available) or reassess if this workload must be exposed to the outseide traffic. If no fix is available, consider periodic restart of the POD to minimize the risk of persistant intrusion. Use exception mechanism if you don't want to see this report again.",
            "id": "C-0084",
            "long_description": "Container images with known Remote Code Execution (RCE) vulnerabilities pose significantly higher risk if they are exposed to the external traffic. This control lists all images with such vulnerabilities if their POD has either LoadBalancer or NodePort service.",
            "test": "This control enumerates external facing workloads, that have LoadBalancer or NodePort service and checks the image vulnerability information for the RCE vulnerability.",
            "controlID": "C-0084",
            "baseScore": 8.0,
            "example": "@controls/examples/c84.yaml",
            "rules": []
        },
        {
            "name": "CVE-2022-3172-aggregated-API-server-redirect",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "security"
                ],
                "attackTracks": []
            },
            "description": "The API server allows an aggregated API to redirect client traffic to any URL. This could lead to the client performing unexpected actions as well as forwarding the client's API server credentials to third parties",
            "remediation": "Upgrade the Kubernetes version to one of the following versions (or higher patchs): `v1.25.1`, `v1.24.5`, `v1.23.11`, `v1.22.14`",
            "id": "C-0089",
            "long_description": "The API server allows an aggregated API  to redirect client traffic to any URL. This could lead to the client performing unexpected actions as well as forwarding the client's API server credentials to third parties",
            "test": "List the aggregated-API-server services that could potentially be used to redirect client traffic to any URL, if the API server version is vulnerable to CVE-2022-3172",
            "controlID": "C-0089",
            "baseScore": 3.0,
            "example": "",
            "rules": []
        },
        {
            "name": "CVE-2022-47633-kyverno-signature-bypass",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "security"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "container",
                        "categories": [
                            "Initial access",
                            "Execution"
                        ]
                    }
                ]
            },
            "description": "CVE-2022-47633 is a high severity vulnerability in Kyverno, it enables attackers to bypass the image signature validation of policies using a malicious image repository or MITM proxy",
            "remediation": "Update your Grafana to 9.2.4 or above",
            "id": "C-0091",
            "long_description": "CVE-2022-47633 is a high severity vulnerability in Kyverno, it enables attackers to bypass the image signature validation of policies using a malicious image repository or MITM proxy. Image signature verification process is used to verify the integrity of the image and prevent the execution of malicious images. The verification process was pull image manifest twice, once for verification and once for the actual execution. The verification process was bypassed by using a malicious image repository or MITM proxy to return a different manifest for the verification process. This vulnerability was fixed in Kyverno 1.8.5. This issue can be mitigated by using only trusted image repositories and by using a secure connection to the image repository. See C-0001 and C-0078 for limiting the use of trusted repositories.",
            "test": "This control test for vulnerable versions of Grafana (between 1.8.3 and 1.8.4)",
            "controlID": "C-0091",
            "baseScore": 8.0,
            "example": "",
            "rules": []
        }
    ],
    "ControlsIDs": [
        "C-0005",
        "C-0038",
        "C-0017",
        "C-0013",
        "C-0057",
        "C-0034",
        "C-0041",
        "C-0009",
        "C-0016",
        "C-0012",
        "C-0035",
        "C-0002",
        "C-0046",
        "C-0055",
        "C-0030",
        "C-0044",
        "C-0058",
        "C-0059",
        "C-0065",
        "C-0061",
        "C-0062",
        "C-0063",
        "C-0054",
        "C-0067",
        "C-0066",
        "C-0068",
        "C-0069",
        "C-0070",
        "C-0001",
        "C-0079",
        "C-0049",
        "C-0078",
        "C-0086",
        "C-0081",
        "C-0087",
        "C-0085",
        "C-0083",
        "C-0084",
        "C-0089",
        "C-0091"
    ]
}