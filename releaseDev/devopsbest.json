{
    "name": "DevOpsBest",
    "description": "",
    "attributes": {
        "armoBuiltin": true
    },
    "version": null,
    "controls": [
        {
            "name": "Naked PODs",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "devops"
                ]
            },
            "description": "It is not recommended to create PODs without parental Deployment, ReplicaSet, StatefulSet etc.Manual creation if PODs may lead to a configuration drifts and other untracked changes in the system. Such PODs won't be automatically rescheduled by Kubernetes in case of a crash or infrastructure failure. This control identifies every POD that does not have corresponding parental object.",
            "remediation": "Create necessary Deployment object for every POD making any POD a first class citizen in your IaC architecture.",
            "id": "C-0073",
            "long_description": "It is not recommended to create PODs without parental Deployment, ReplicaSet, StatefulSet etc.Manual creation if PODs may lead to a configuration drifts and other untracked changes in the system. Such PODs won't be automatically rescheduled by Kubernetes in case of a crash or infrastructure failure. This control identifies every POD that does not have corresponding parental object.",
            "test": "Test if PODs are not associated with Deployment, ReplicaSet etc. If not, fail.",
            "controlID": "C-0073",
            "baseScore": 3,
            "rules": []
        },
        {
            "name": "Containers mounting Docker socket",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "devops"
                ]
            },
            "description": "Mounting Docker socket (Unix socket) enables container to access Docker internals, retrieve sensitive information and execute Docker commands, if Docker runtime is available. This control identifies PODs that attempt to mount Docker socket for accessing Docker runtime.",
            "remediation": "Remove docker socket mount request or define an exception.",
            "id": "C-0074",
            "long_description": "Mounting Docker socket (Unix socket) enables container to access Docker internals, retrieve sensitive information and execute Docker commands, if Docker runtime is available. This control identifies PODs that attempt to mount Docker socket for accessing Docker runtime.",
            "test": "Check hostpath. If the path is set to /var/run/docker.sock or /var/lib/docker , the container has access to Docker internals - fail.",
            "controlID": "C-0074",
            "baseScore": 5,
            "rules": []
        },
        {
            "name": "Image pull policy on latest tag",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "devops"
                ]
            },
            "description": "While usage of the latest tag is not generally recommended, in some cases this is necessary. If it is, the ImagePullPolicy must be set to Always, otherwise Kubernetes may run an older image with the same name that happens to be present in the node cache. Note that using Always will not cause additional image downloads because Kubernetes will check the image hash of the local local against the registry and only pull the image if this hash has changed, which is exactly what users want when use the latest tag. This control will identify all PODs with latest tag that have ImagePullSecret not set to Always.",
            "remediation": "Set ImagePullPolicy to Always in all PODs found by this control.",
            "id": "C-0075",
            "long_description": "While usage of the latest tag is not generally recommended, in some cases this is necessary. If it is, the ImagePullPolicy must be set to Always, otherwise Kubernetes may run an older image with the same name that happens to be present in the node cache. Note that using Always will not cause additional image downloads because Kubernetes will check the image hash of the local local against the registry and only pull the image if this hash has changed, which is exactly what users want when use the latest tag. This control will identify all PODs with latest tag that have ImagePullSecret not set to Always. Note as well that some vendors don't use the word latest in the tag. Some other word may also behave like the latest. For example, Redis uses redis:alpine to signify the latest. Therefore, this control treats any word that does not contain digits as the latest. If no tag is specified, the image is treated as latests too.",
            "test": "If  imagePullPolicy = always pass, else fail.",
            "controlID": "C-0075",
            "baseScore": 2,
            "rules": []
        },
        {
            "name": "Label usage for resources",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "devops"
                ]
            },
            "description": "It is recommended to set labels that identify semantic attributes of your application or deployment. For example, { app: myapp, tier: frontend, phase: test, deployment: v3 }. These labels can used to assign policies to logical groups of the deployments as well as for presentation and tracking purposes. This control helps you find deployments without any of the expected labels.",
            "remediation": "Define labels that are most suitable to your needs of use the exceptions to prevent further notifications.",
            "id": "C-0076",
            "long_description": "It is recommended to set labels that identify semantic attributes of your application or deployment. For example, { app: myapp, tier: frontend, phase: test, deployment: v3 }. These labels can used to assign policies to logical groups of the deployments as well as for presentation and tracking purposes. This control helps you find deployments without any of the expected labels.",
            "test": "Test will check if a certain set of labels is defined, this is a configurable control. Initial list: app, tier, phase, version, owner, env.",
            "controlID": "C-0076",
            "baseScore": 2,
            "rules": []
        },
        {
            "name": "K8s common labels usage",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "devops"
                ]
            },
            "description": "Kubernetes common labels help manage and monitor Kubernetes cluster using different tools such as kubectl, dashboard and others in an interoperable way. Refer to https://kubernetes.io/docs/concepts/overview/working-with-objects/common-labels/ for more information. This control helps you find objects that don't have any of these labels defined.",
            "remediation": "Define applicable labels or use the exception mechanism to prevent further notifications.",
            "id": "C-0077",
            "long_description": "Kubernetes common labels help manage and monitor Kubernetes cluster using different tools such as kubectl, dashboard and others in an interoperable way. Refer to https://kubernetes.io/docs/concepts/overview/working-with-objects/common-labels/ for more information. This control helps you find objects that don't have any of these labels defined.",
            "test": "Test will check if the list of label that start with app.kubernetes.io/ are defined.",
            "controlID": "C-0077",
            "baseScore": 2.0,
            "rules": []
        },
        {
            "name": "Pods in default namespace",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "compliance",
                    "devops"
                ]
            },
            "description": "It is recommended to avoid running PODs in cluster without explicit namespace assignment. This control identifies all the PODs running in the default namespace.",
            "remediation": "Create necessary namespaces and move all the PODs from default namespace there.",
            "id": "C-0061",
            "long_description": "It is recommended to avoid running PODs in cluster without explicit namespace assignment. This may lead to wrong capabilities and permissions assignment and potential compromises. This control identifies all the PODs running in the default namespace.",
            "test": "Check that there are no pods in the 'default' namespace",
            "controlID": "C-0061",
            "baseScore": 3,
            "rules": []
        },
        {
            "name": "Container hostPort",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "security",
                    "compliance",
                    "devops"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "container",
                        "categories": [
                            "Initial access"
                        ]
                    }
                ]
            },
            "description": "Configuring hostPort requires a particular port number. If two objects specify the same HostPort, they could not be deployed to the same node. It may prevent the second object from starting, even if Kubernetes will try reschedule it on another node, provided there are available nodes with sufficient amount of resources. Also, if the number of replicas of such workload is higher than the number of nodes, the deployment will consistently fail.",
            "remediation": "Avoid usage of hostPort unless it is absolutely necessary, in which case define appropriate exception. Use NodePort / ClusterIP instead.",
            "id": "C-0044",
            "long_description": "Workloads (like pod, deployment, etc) that contain a container with hostport. The problem that arises is that if the scale of your workload is larger than the number of nodes in your Kubernetes cluster, the deployment fails. And any two workloads that specify the same HostPort cannot be deployed to the same node. In addition, if the host where your pods are running becomes unavailable, Kubernetes reschedules the pods to different nodes. Thus, if the IP address for your workload changes, external clients of your application will lose access to the pod. The same thing happens when you restart your pods \u2014 Kubernetes reschedules them to a different node if available.\u00a0",
            "test": "Check for each workload (with container) if it exists inside the container hostPort.\u00a0\u00a0",
            "controlID": "C-0044",
            "baseScore": 4.0,
            "example": "@controls/examples/c044.yaml",
            "rules": []
        },
        {
            "name": "Resources CPU limit and request",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "compliance",
                    "devops"
                ]
            },
            "description": "This control identifies all Pods for which the CPU limit is not set.",
            "remediation": "Set the CPU limit or use exception mechanism to avoid unnecessary notifications.",
            "id": "C-0050",
            "controlID": "C-0050",
            "baseScore": 8.0,
            "rules": []
        },
        {
            "name": "Resources memory limit and request",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "compliance",
                    "devops"
                ],
                "attackTracks": [
                    {
                        "attackTrack": "container",
                        "categories": [
                            "Impact - service destruction"
                        ]
                    }
                ]
            },
            "description": "This control identifies all Pods for which the memory limit is not set.",
            "remediation": "Set the memory limit or use exception mechanism to avoid unnecessary notifications.",
            "id": "C-0004",
            "controlID": "C-0004",
            "example": "@controls/examples/c004.yaml",
            "baseScore": 8.0,
            "rules": []
        },
        {
            "name": "Configured liveness probe",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "devops"
                ]
            },
            "description": "Liveness probe is intended to ensure that workload remains healthy during its entire execution lifecycle, or otherwise restrat the container. It is highly recommended to define liveness probe for every worker container. This control finds all the PODs where the Liveness probe is not configured.",
            "remediation": "Ensure Liveness probes are configured wherever possible.",
            "id": "C-0056",
            "long_description": "Liveness probe is intended to ensure that workload remains healthy during its entire execution lifecycle, or otherwise restrat the container. It is highly recommended to define liveness probe for every worker container. This control finds all the PODs where the Liveness probe is not configured.",
            "controlID": "C-0056",
            "baseScore": 4,
            "rules": []
        },
        {
            "name": "Configured readiness probe",
            "attributes": {
                "armoBuiltin": true,
                "controlTypeTags": [
                    "devops"
                ]
            },
            "description": "Readiness probe is intended to ensure that workload is ready to process network traffic. It is highly recommended to define readiness probe for every worker container. This control finds all the PODs where the readiness probe is not configured.",
            "remediation": "Ensure Readiness probes are configured wherever possible.",
            "id": "C-0018",
            "long_description": "Readiness probe is intended to ensure that workload is ready to process network traffic. It is highly recommended to define readiness probe for every worker container. This control finds all the PODs where the readiness probe is not configured.",
            "controlID": "C-0018",
            "example": "@controls/examples/c018.yaml",
            "baseScore": 3,
            "rules": []
        }
    ],
    "ControlsIDs": [
        "C-0073",
        "C-0074",
        "C-0075",
        "C-0076",
        "C-0077",
        "C-0061",
        "C-0044",
        "C-0050",
        "C-0004",
        "C-0056",
        "C-0018"
    ]
}